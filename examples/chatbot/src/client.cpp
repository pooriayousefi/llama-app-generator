/*
 * Copyright 2025 Pooria Yousefi
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file client.cpp
 * @brief CLI Client for {{PROJECT_NAME}} Server
 * 
 * Demonstrates how to communicate with the app-server on port_y.
 * This is the "GUI/CLI client" component from the architecture diagram.
 * 
 * @example Usage
 * @code
 *   ./client echo "Hello World"
 *   ./client complete "What is the meaning of life?"
 *   ./client chat "Tell me a joke"
 *   ./client summarize "Long text here..."
 * @endcode
 * 
 * Generated by llama-app-generator on {{DATE}}
 * 
 * @author Pooria Yousefi
 */

#include <iostream>
#include <string>
#include "httplib.h"
#include "json.hpp"
#include "runtime_config.hpp"

using json = nlohmann::json;
using namespace pooriayousefi::llama::app;

namespace color
{
    const std::string RESET = "\033[0m";
    const std::string RED = "\033[31m";
    const std::string GREEN = "\033[32m";
    const std::string YELLOW = "\033[33m";
    const std::string BLUE = "\033[34m";
    const std::string CYAN = "\033[36m";
}

/**
 * @brief Send HTTP POST request to app-server
 * 
 * @param host Server hostname
 * @param port Server port
 * @param request JSON request object
 * @return JSON response
 * 
 * @throws std::runtime_error if request fails
 */
json call_server(const std::string& host, int port, const json& request)
{
    httplib::Client client(host, port);
    client.set_read_timeout(std::chrono::seconds(300));
    client.set_write_timeout(std::chrono::seconds(300));
    
    std::string request_body = request.dump();
    
    auto res = client.Post("/api", request_body, "application/json");
    
    if (!res)
    {
        throw std::runtime_error("HTTP request failed: connection error");
    }
    
    if (res->status != 200)
    {
        throw std::runtime_error("HTTP request failed with status: " + std::to_string(res->status));
    }
    
    return json::parse(res->body);
}

/**
 * @brief Print usage information
 */
void print_usage(const char* program_name)
{
    std::cout << color::CYAN << "{{PROJECT_NAME}} CLI Client" << color::RESET << std::endl;
    std::cout << color::CYAN << "namespace: pooriayousefi::llama::app" << color::RESET << std::endl;
    std::cout << std::endl;
    std::cout << "Usage: " << program_name << " <action> <argument> [config_file]" << std::endl;
    std::cout << std::endl;
    std::cout << color::YELLOW << "Actions:" << color::RESET << std::endl;
    std::cout << "  echo <message>           - Echo message back (no LLM)" << std::endl;
    std::cout << "  complete <prompt>        - LLM text completion" << std::endl;
    std::cout << "  chat <message>           - Chat with LLM" << std::endl;
    std::cout << "  summarize <text>         - Text summarization" << std::endl;
    std::cout << std::endl;
    std::cout << color::YELLOW << "Arguments:" << color::RESET << std::endl;
    std::cout << "  config_file              - Path to config.txt (default: config.txt)" << std::endl;
    std::cout << std::endl;
    std::cout << color::YELLOW << "Examples:" << color::RESET << std::endl;
    std::cout << "  " << program_name << " echo \"Hello World\"" << std::endl;
    std::cout << "  " << program_name << " complete \"Explain quantum computing\"" << std::endl;
    std::cout << "  " << program_name << " chat \"Tell me a joke\"" << std::endl;
    std::cout << "  " << program_name << " summarize \"Long text...\"" << std::endl;
    std::cout << std::endl;
}

/**
 * @brief Main entry point
 */
int main(int argc, char* argv[])
{
    if (argc < 3)
    {
        print_usage(argv[0]);
        return 1;
    }
    
    std::string action = argv[1];
    std::string argument = argv[2];
    std::string config_path = (argc >= 4) ? argv[3] : "config.txt";
    
    try
    {
        // Load configuration to get app-server port
        RuntimeConfig config = RuntimeConfig::from_file(config_path);
        
        // Build request
        json request;
        
        if (action == "echo")
        {
            request = {
                {"action", "echo"},
                {"message", argument}
            };
        }
        else if (action == "complete")
        {
            request = {
                {"action", "complete"},
                {"prompt", argument}
            };
        }
        else if (action == "chat")
        {
            request = {
                {"action", "chat"},
                {"message", argument}
            };
        }
        else if (action == "summarize")
        {
            request = {
                {"action", "summarize"},
                {"text", argument}
            };
        }
        else
        {
            std::cerr << color::RED << "✗ Unknown action: " << action << color::RESET << std::endl;
            print_usage(argv[0]);
            return 1;
        }
        
        // Send request
        std::cout << color::BLUE << "Sending request..." << color::RESET << std::endl;
        std::cout << "  Action: " << action << std::endl;
        std::cout << "  Server: localhost:" << config.app_server_port << std::endl;
        std::cout << std::endl;
        
        json response = call_server("localhost", config.app_server_port, request);
        
        // Display response
        std::string status = response.value("status", "unknown");
        
        if (status == "success")
        {
            std::cout << color::GREEN << "✓ Success" << color::RESET << std::endl;
            std::cout << std::endl;
            
            // Print relevant response fields
            if (response.contains("completion"))
            {
                std::cout << color::CYAN << "Completion:" << color::RESET << std::endl;
                std::cout << response["completion"] << std::endl;
            }
            else if (response.contains("ai_response"))
            {
                std::cout << color::CYAN << "AI Response:" << color::RESET << std::endl;
                std::cout << response["ai_response"] << std::endl;
            }
            else if (response.contains("summary"))
            {
                std::cout << color::CYAN << "Summary:" << color::RESET << std::endl;
                std::cout << response["summary"] << std::endl;
            }
            else if (response.contains("message"))
            {
                std::cout << color::CYAN << "Message:" << color::RESET << std::endl;
                std::cout << response["message"] << std::endl;
            }
            else
            {
                std::cout << color::CYAN << "Full Response:" << color::RESET << std::endl;
                std::cout << response.dump(2) << std::endl;
            }
        }
        else
        {
            std::cout << color::RED << "✗ Request failed" << color::RESET << std::endl;
            std::cout << std::endl;
            
            if (response.contains("message"))
            {
                std::cout << color::RED << "Error: " << response["message"] << color::RESET << std::endl;
            }
            else
            {
                std::cout << color::RED << "Full Response:" << color::RESET << std::endl;
                std::cout << response.dump(2) << std::endl;
            }
            
            return 1;
        }
        
        return 0;
    }
    catch (const std::exception& e)
    {
        std::cerr << color::RED << "✗ Error: " << e.what() << color::RESET << std::endl;
        return 1;
    }
}
